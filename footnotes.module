<?php
// $Id$

/**
 * @file
 * The Footnotes module is a filter that can be used to insert
 * automatically numbered footnotes into Drupal texts.
 *
 * Currently there are two filters. One is suitable for use primarily with html markup,
 * but can be used with any input format. The second filter outputs footnotes in 
 * Textile format. This means you should run this filter together and before the 
 * Textile filter.
 */

/**
 * Implementation of hook_help().
 *
 * Throughout Drupal, hook_help() is used to display help text at the top of
 * pages. Some other parts of drupal pages get explanatory text from these hooks
 * as well. We use it here to provide a description of the module on the
 * module administration page.
 */
function footnotes_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      // This description is shown in the listing at admin/modules.
      return t('Insert automatically numbered footnotes into Drupal texts. (Also includes Better URL filter.)');
  }
}

/**
 * Implementation of hook_filter_tips().
 *
 * This hook allows filters to provide help text to users during the content
 * editing process. Short tips are provided on the content editing screen, while
 * long tips are provided on a separate linked page. Short tips are optional,
 * but long tips are highly recommended.
 */
function footnotes_filter_tips($delta, $format, $long = FALSE) {

  switch ($delta) {
    case 0:
      if ($long) {
        return t('You can insert footnotes directly into texts with <code>[fn]This text becomes a footnote.[/fn]</code>. This will be replaced with a running number (the footnote reference) and the text within the [fn] tags will be moved to the bottom of the page (the footnote).');
      }
      else {
        return t('Use [fn]...[/fn] (or &lt;fn&gt;...&lt;/fn&gt;) to insert automatically numbered footnotes.');
      }
      break;

    case 1:
      if ($long) {
        return t('You can insert footnotes directly into texts with [# ...]. This will be replaced with a running number (the footnote reference) and the text within the [# ...] tags will be moved to the bottom of the page (the footnote). <em>This filter outputs footnotes in Textile format. You should use it together and before the Textile filter.</em>');
      }
      else {
        return t('Use [# ...] to insert automatically numbered footnotes. Textile variant.');
      }
      break;

    case 99:
      return t('Web page addresses and e-mail addresses turn into links automatically. (Better URL filter.)');
      break;

  }
}

/**
 * Implementation of hook_filter().
 *
 * The bulk of filtering work is done here. This hook is quite complicated, so
 * we'll discuss each operation it defines.
 */
function footnotes_filter($op, $delta = 0, $format = -1, $text = '') {
  // The "list" operation provides the module an opportunity to declare both how
  // many filters it defines and a human-readable name for each filter. Note that
  // the returned name should be passed through t() for translation.
  if ($op == 'list') {
    return array(
      0 => t('Footnotes [fn]...[/fn]'),
      1 => t('Footnotes Textile style'),
      99 => t('Better URL filter (fork from core)')
    );
  }

  // All operations besides "list" provide a $delta argument so we know which
  // filter they refer to. We'll switch on that argument now so that we can
  // discuss each filter in turn.
  switch ($delta) {

    // First is the html footnotes filter
    case 0:

      switch ($op) {
        // This description is shown in the administrative interface, unlike the
        // filter tips which are shown in the content editing interface.
        case 'description':
        return t('Use [fn]...[/fn] (or &lt;fn&gt;...&lt;/fn&gt;) to insert automatically numbered footnotes.');

        // We don't need the "prepare" operation for this filter, but it's required
        // to at least return the input text as-is.
        case 'prepare':
          return $text;

        // The actual filtering is performed here. The supplied text should be
        // returned, once any necessary substitutions have taken place.
        case 'process':
          // Supporting both [fn] and <fn> now. Thanks to fletchgqc http://drupal.org/node/268026
          $pattern = array('|\[fn](.*?)\[/fn]|s', '|<fn>(.*?)</fn>|s');
          $text = preg_replace_callback($pattern , '_footnotes_replace_callback', $text);
          //$text = preg_replace_callback('|<fn>(.*?)</fn>|s', '_footnotes_replace_callback', $text);

          //Replace tag <footnotes> with the list of footnotes.
          //If tag is not present, by default add the footnotes at the end.
          //Thanks to acp on drupal.org for this idea. see http://drupal.org/node/87226 
          $footer = '';
          $footer = _footnotes_replace_callback(NULL, 'output footer');
          $pattern = '/(\[footnotes(( )?\/)?\])|(<footnotes(( )?\/)?>)/';
          if(preg_match($pattern, $text) > 0) {
            $text = preg_replace($pattern, $footer, $text, 1);
            return $text;
          }
          else {
            return $text . "\n\n" . $footer;
          }
      }
      break;

    // Textile version.
    case 1:

      switch ($op) {
        // This description is shown in the administrative interface, unlike the
        // filter tips which are shown in the content editing interface.
        case 'description':
          return t('Use [# ...] to insert automatically numbered footnotes in Textile markup.');

        // We don't need the "prepare" operation for this filter, but it's required
        // to at least return the input text as-is.
        case 'prepare':
          return $text;

        // The actual filtering is performed here. The supplied text should be
        // returned, once any necessary substitutions have taken place.
        case 'process':
          $text = preg_replace_callback('|\[# (.*?)\]|s', '_footnotes_replace_callback_textile', $text);

          //Replace Textile tag "footnotes." with the list of footnotes.
          //If tag is not present, by default add the footnotes at the end.
          //Thanks to acp on drupal.org for this idea. see http://drupal.org/node/87226 
          $footer = '';
          $footer = _footnotes_replace_callback_textile(NULL, 'output footer');
          if( preg_match( '/\n *footnotes\. *(\n|$)/', $text ) > 0 ) {
            $text = preg_replace('/\n *footnotes\. *(\n|$)/', "\n$footer\n", $text, 1);
            return $text;
          }
          else {
            return $text . "\n\n" . $footer;
          }
      }
      break;

    case 99:
      switch ($op) {
        case 'description':
          return t('Better URL filter: Turns web and e-mail addresses into clickable links. NOTE: This filter is an enhancement to the Drupal core URL filter and will be deprecated if the enhancements are ever committed to Drupal core. <a href="http://drupal.org/node/161217">#161217</a>');

        // We don't need the "prepare" operation for this filter, but it's required
        // to at least return the input text as-is.
        case 'prepare':
          return $text;

        case 'process':
          return _footnotes_filter_url($text, $format);

        case 'settings':
          return _footnotes_filter_url_settings($format);
      }
      break;

  }
}


/**
 * Helper function called from preg_replace_callback() above
 *
 * Uses static vars to temporarily store footnotes found.
 * In my understanding, this is not threadsafe?!
 */
function _footnotes_replace_callback( $matches, $op = '' ) {
  static $n = 0;
  static $store_matches = array();
  $str = '';
  
  if( $op == 'output footer' ) {
    if( $n > 0 ) {
      $str = '<ol class="footnotes">';
      for( $m = 1; $m <= $n; $m++ ){
        $text = $store_matches[ $m - 1 ][0];
        $randstr = $store_matches[ $m - 1 ][1];
        $str .= '<li><a class="footnote" name="footnote' . $m . '_' . $randstr .
                '" href="#footnoteref' . $m . '_' . $randstr . '">' . $m . '.</a> ';
        $str .= $text . "</li>\n";
      }
      $str .= "</ol>\n";
    }
    $n = 0;
    $store_matches = array();
    return $str;
  }


  //default op: act as called by preg_replace_callback()
  //Random string used to ensure footnote id's are unique, even 
  //when contents of multiple nodes reside on same page. (fixes http://drupal.org/node/194558)
  $randstr = _footnotes_helper_randstr();

  array_push( $store_matches, array( $matches[1], $randstr ) );
  $n++;
  $allowed_tags = array();
  $title = filter_xss($matches[1], $allowed_tags);
  //html attribute cannot contain quotes
  $title = str_replace('"', "&quot;", $title);
  //remove newlines. Browsers don't support them anyway and they'll confuse line break converter in filter.module
  $title = str_replace("\n", " ", $title);
  $title = str_replace("\r", "", $title);
  return '<a class="see_footnote" id="footnoteref' . $n . '_' . $randstr .
         '" title="' . $title . '" href="#footnote' . $n . '_' . $randstr . '">' . $n . '</a>';
}


/**
 * Helper function called from preg_replace_callback() above
 *
 * Uses static vars to temporarily store footnotes found.
 * In my understanding, this is not threadsafe?!
 */
function _footnotes_replace_callback_textile( $matches, $op = '' ) {
  static $n = 0;
  static $store_matches = array();
  $str = '';
  
  if( $op == 'output footer' ) {
    if( $n > 0 ) {
      $str = '';
      for( $m = 1; $m <= $n; $m++ ){
        $str .= "fn$m. " . $store_matches[ $m - 1 ] . "\n\n";
      }
    }
    $n = 0;
    $store_matches = array();
    return $str;
  }

  //default op: act as called by preg_replace_callback()
  array_push( $store_matches, $matches[1] );
  $n++;
  return '[' . $n . ']';  
}

/**
 * Helper function to return a random text string
 *
 * @return random (lowercase) alphanumeric string
 */
function _footnotes_helper_randstr() {
  $chars = "abcdefghijklmnopqrstuwxyz1234567890";
  $str = "";
  
  //seeding with srand() not neccessary in modern PHP versions
  for( $i = 0; $i < 7; $i++ ) {
    $n = rand( 0, strlen( $chars ) - 1 );
    $str .= substr( $chars, $n, 1 );
  }
  return $str;
}

/**
* Implementation of hook_init()
*
* Add special css for Footnotes module.
*
* Thanks to binford2k@lug.wsu.edu for this tip and drinkypoo
* for the question leading up to it. http://drupal.org/node/80538
*/
function footnotes_init() {
  drupal_add_css(drupal_get_path('module', 'footnotes') .'/footnotes.css');
}

/**
* Helper for other filters, check if Footnotes is present in your filter chain.
*
* Other filters may leverage the Footnotes functionality in a simple way:
* by outputting markup with <fn>...</fn> tags within. 

* This creates a dependency, the Footnotes filter must be present later in 
* "Input format". By calling this helper function the other filters that 
* depend on Footnotes may check whether Footnotes is present later in the chain
* of filters in the current Input format.
*
* If this function returns true, the caller may depend on Footnotes. Function returns
* false if caller may not depend on Footnotes.
* 
* Example usage:
* <code>
* filter_example_filter( $op, $delta = 0, $format = -1, $text = '') {
*   ...
*   //When caller wishes to depend on html footnotes, last argument may be omitted
*   if( footnotes_is_footnotes_later( $format, 'filter_example_filter', $delta ) ) {
*     //output markup which may include <fn> tags
*   }
*   else {
*     // must make do without footnotes features
*   }
*   ...
* }
* </code>
*
* Note: You should also put "dependencies = footnotes" in your module.info file.
*
* @param $format
*    The input format caller is being run as part of ($format of hook_filter(...))
* @param $caller
*    Name of calling module
* @param $caller_delta
*    Delta of the filter within calling module ($delta of hook_filter(...))
* @param $footnotes_delta
*    Delta of the filter within footnotes module
*
* @return True if Footnotes is present after $caller in Input format $format
*/
function footnotes_is_footnotes_later( $format, $caller, $caller_delta=0, $footnotes_delta=0) {
    //Determine caller's weight in the current input format
    $result = 
       db_query( "SELECT weight FROM filters WHERE module='%s' AND format=%d AND delta=%d;",
                        $caller, $format, $caller_delta );
    $caller_weight = db_fetch_object( $result );
    $caller_weight = $caller_weight->weight;

    //See if Footnotes is present in the input format and if weight is higher
    $result = 
       db_query( "SELECT weight FROM filters WHERE module='%s' AND format=%d AND delta=%d;",
                        'footnotes', $format, $footnotes_delta );
    $fn_weight = db_fetch_object( $result );
    if( $fn_weight ) {
      $fn_weight = $fn_weight->weight;
    }
    else {
      //Footnotes is not present at all in input format $format
      return FALSE;
    }
    
    if( $fn_weight > $caller_weight ) {
      //Footnotes is after caller in input format $format
      return TRUE;
    }
    else {
      //Footnotes is before caller in input format $format
      return FALSE;
      //TODO: What is correct interpretation when weight is equal?
    }
}






/**********************************************************************************************************
 * The URL filter shipped in Drupal core filter.module is buggy (or rather, too simple). Footnotes users
 * in particular are affected since URL's in footnotes don't get converted into links even if they should.
 *
 * I've submitted a patch for a better URL filter a year ago, but the core developers have not committed it.
 * There are no bugs or anything, just that nobody is paying attention.
 * http://drupal.org/node/161217
 *
 * To end the misery, I'm publishing the good version of URL filter within the Footnotes module. The URL 
 * filter related code is below, plus a few snippets above in footnotes_filter and footnotes_filter_tips.
 *
 * This forked "Better URL filter" will be deprecated if the code is ever committed to Drupal core.
 **********************************************************************************************************
 */




/**
 * Settings for URL filter.
 */
function _footnotes_filter_url_settings($format) {
  $form['footnotes_filter_urlfilter'] = array(
    '#type' => 'fieldset',
    '#title' => t('Better URL filter'),
    '#collapsible' => TRUE,
  );
  $form['footnotes_filter_urlfilter']['footnotes_filter_url_length_' . $format] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum link text length'),
    '#default_value' => variable_get('footnotes_filter_url_length_' . $format, 72),
    '#maxlength' => 4,
    '#description' => t('URLs longer than this number of characters will be truncated to prevent long strings that break formatting. The link itself will be retained; just the text portion of the link will be truncated.'),
  );
  return $form;
}

/**
 * URL filter. Automatically converts text web addresses (URLs, e-mail addresses,
 * ftp links, etc.) into hyperlinks.
 */
function _footnotes_filter_url($text, $format) {
  // List of tags - the content of which must be skipped.
  $ignoretags = 'a|script|style|code';

  // This filter identifies and makes clickable links of 3 types of "links".
  // 1) URL's like http://www.example.com.
  // 2) e-mail addresses like name@example.com.
  // 3) Web addresses without the "http://" protocol defined, like www.example.com.
  // Each type must be processed separately, as there is no one regular expression
  // that could possibly match all of the cases in one pass.
  //
  // Create an array which contains the regexps for each type of link.
  // The key to the regexp is the name of a function that is used as
  // callback function to process matches of the regexp. The callback function
  // is to return the replacement for the match.
  // The array is used and matching/replacement done below inside some loops.
  $tasks = NULL;
  // Match absolute URLs.
  $protocols = 'http://|https://|ftp://|mailto:|smb://|afp://|file://|gopher://|news://|ssl://|sslv2://|sslv3://|tls://|tcp://|udp://';
  $urlpattern = "(?:$protocols)(?:[a-zA-Z0-9@:%_+*~#?&=.,/;-]*[a-zA-Z0-9@:%_+*~#&=/;-])";
  $re = "`($urlpattern)([\.\,\?\!]*?)`i";
  $tasks['_footnotes_filter_url_parse_full_links'] = $re;
  // Match e-mail addresses.
  // Note: The ICANN seems to be on track towards accepting more diverse top level domains,
  // so this pattern has been "future-proofed" to allow for TLD's of length 2-64.
  $urlpattern = '[A-Za-z0-9._-]+@[A-Za-z0-9._+-]+\.[A-Za-z]{2,64}';
  $re = "`($urlpattern)`i";
  $tasks['_footnotes_filter_url_parse_email_links'] = $re;
  // Match www domains/addresses.
  $urlpattern = 'www\.[a-zA-Z0-9@:%_+*~#?&=.,/;-]*[a-zA-Z0-9@:%_+~#\&=/;-]';
  $re = "`($urlpattern)([\.\,\?\!]*?)`i";
  $tasks['_footnotes_filter_url_parse_partial_links'] = $re;

  // Pass length to regexp callback.
  _footnotes_filter_url_trim(NULL, variable_get('footnotes_filter_url_length_' . $format, 72));

  // We need to process each case of replacement type separately.
  // The text must be joined and split again after each
  // replacement, since replacements create new HTML tags and the new
  // tags must be correctly protected before the next replacement can be done.
  foreach ($tasks as $task => $re) {
    // Split at all tags.
    // This ensures that nothing that is a tagname or attribute will be processed.
    $chunks = preg_split('/(<.+?>)/i', $text, -1, PREG_SPLIT_DELIM_CAPTURE);
    // Note: PHP ensures the array consists of alternating delimiters and literals
    // and begins and ends with a literal (inserting NULL as required).
    // Therefore, first chunk is always text:
    $chunk_type = 'text';
    // Tags to ignore are defined in $ignoretags (see above).
    // If an ignoretag is found, it is stored here and removed only when the
    // closing tag is found. Until the closing tag is found, no replacements are made.
    $opentag = '';

    for ($i = 0; $i < count($chunks); $i++) {
      if ($chunk_type == 'text') {
        // Only do replacements when there are no unclosed ignoretags.
        if ($opentag == '') {
          // This is the high point of this function! If there is a match,
          // a link is created in the callback function named by $task.
          $chunks[$i] = preg_replace_callback($re, $task, $chunks[$i]);
        }
        // Done processing text chunk, so next chunk is a tag.
        $chunk_type = 'tag';
      }
      else {
        if ($opentag == '') {
          // No open ignoretags. Process this tag...
          if (preg_match("`<($ignoretags)(?:\s|>)`i", $chunks[$i], $matches)) {
            // This matches one of the $ignoretags.
            // Catch and store the tag in question.
            $opentag = $matches[1];
          }
        }
        else {
          // There is an $ignoretag open. See if this is a matching closing tag.
          // Nothing else is done until we find the closing tag.
          if (preg_match("`<\/$opentag>`i", $chunks[$i], $matches)) {
            $opentag = '';
          }
        }
        // Done processing tag chunk, so next chunk is text.
        $chunk_type = 'text';
      }
    }
  $text = implode($chunks);
  }

  return $text;
}
/**
 * Callback function. Make links out of absolute URLs.
 */
function _footnotes_filter_url_parse_full_links($match) {
  // The $i:th parenthesis in the regexp contains the URL.
  $i = 1;

  $match[$i] = decode_entities($match[$i]);
  $caption = check_plain(_footnotes_filter_url_trim($match[$i]));
  $match[$i] = check_url($match[$i]);
  return '<a href="' . $match[$i] . '" title="' . $match[$i] . '">' . $caption . '</a>' . $match[$i+1];
}

/**
 * Callback function. Make links out of e-mail addresses.
 */
function _footnotes_filter_url_parse_email_links($match) {
  // The $i:th parenthesis in the regexp contains the URL.
  $i = 0;

  $match[$i] = decode_entities($match[$i]);
  $caption = check_plain(_footnotes_filter_url_trim($match[$i]));
  $match[$i] = check_url($match[$i]);
  return '<a href="mailto:' . $match[$i] . '" title="' . $match[$i] . '">' . $caption . '</a>';
}

/**
 * Callback function. Make links out of domain names starting with "www.".
 */
function _footnotes_filter_url_parse_partial_links($match) {
  // The $i:th parenthesis in the regexp contains the URL.
  $i = 1;

  $match[$i] = decode_entities($match[$i]);
  $caption = check_plain(_footnotes_filter_url_trim($match[$i]));
  $match[$i] = check_plain($match[$i]);
  return '<a href="http://' . $match[$i] . '" title="' . $match[$i] . '">' . $caption . '</a>' . $match[$i+1];
}

/**
 * Shortens long URLs to http://www.example.com/long/url...
 */
function _footnotes_filter_url_trim($text, $length = NULL) {
  static $_length;
  if ($length !== NULL) {
    $_length = $length;
  }

  if (strlen($text) > $_length) {
    $text = substr($text, 0, $_length) . '...';
  }

  return $text;
}

/**** End of Better URL filter code. Now returning to our normally scheduled Footnotes programming. *****/
/********************************************************************************************************/
